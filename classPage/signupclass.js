const {
    UserName,
    Password,
    ConfirmPassword,
    ErrorMessage,
    secretPasscodefield,
    passcodeEyeIcon,
    NextButton,
    copyPasscodeButton,
    confirmButton,
    createAccountButton,
    SubmitSignForm,
    eyeIconPasswordXpath,
    eyeIconConfirmPassXpath,
    secretPasscodeFieldXpath,
    NextButtonxPath,
    ConfirmSecretpasscodePageXpath,
    secretPasscodeFieldIndropDown,
    countrySelectorDropdown

} = require('../pageElements/signUp.js');

const { expect } = require('@playwright/test');

const BasePage = require('../classPage/baseclass.js')

class SignUp extends BasePage {
    constructor(page) {
        super(page);
    };
    async clickCreateAnAccountButton() {
        await this.click(createAccountButton);
    };
    async fillSignUpform(username, password, confirmPassword) {
        await this.fillInput(UserName, username);
        await this.fillInput(Password, password);
        await this.fillInput(ConfirmPassword, confirmPassword);
    };
    async submitForm() {
        await this.click(SubmitSignForm)
    };
    async togglePasswordVisibility() {
        await this.click(eyeIconPasswordXpath);
        const  typeAttribute =await this.getAttribute(Password, 'type');
        expect(typeAttribute).toBe('text')
        return await this.getAttribute(Password, 'type') === 'text'
            ? await this.page.inputValue(Password)
            : '';
    }

    async isPasswordHidden() {
        return await this.getAttribute(Password, 'type') === 'password';
    }

    async toogleConfirmPassVisibility() {
        await this.click(eyeIconConfirmPassXpath);
        const  typeAttribute =await this.getAttribute(ConfirmPassword, 'type');
        expect(typeAttribute).toBe('text')
        return await this.getAttribute(ConfirmPassword, 'type') === 'text'
            ? await this.page.inputValue(ConfirmPassword)
            : '';
    }
    async isConfirmPassHidden() {
        return await this.getAttribute(ConfirmPassword, 'type') === 'password';
    }

    async isSecretPasscodeAutoGeneratedAndNotEditable() {
        // Wait for the secret passcode field to appear on the page
        await this.page.waitForSelector(secretPasscodeFieldXpath);

        // Get the value of the secret passcode (to check if it's auto-generated)
        const passcodeValue = await this.page.$eval(secretPasscodeFieldXpath, el => el.value);

        // Check if the input field is readonly or disabled (to ensure it is not editable)
        const isReadOnly = await this.page.$eval(secretPasscodeFieldXpath, el => el.readOnly);
        const isDisabled = await this.page.$eval(secretPasscodeFieldXpath, el => el.disabled);

        // Return true if passcode is not empty and the field is either readonly or disabled
        return passcodeValue !== '' && (isReadOnly || isDisabled);
    };

    async toggleSecretPasscodeVisibility() {
        await this.click(passcodeEyeIcon);
        return await this.getAttribute(secretPasscodeFieldXpath, 'type') === 'text'
            ? await this.page.inputValue(secretPasscodeFieldXpath)
            : '';
    }

    async isSecretPasscodeHidden() {
        return await this.getAttribute(secretPasscodeFieldXpath, 'type') === 'password';
    }

    async isNextButtonDisabled() {
        // Wait for the "Next" button to appear
        await this.page.waitForSelector(NextButtonxPath, { timeout: 5000 });
        // Check if the "Next" button is disabled
        const isDisabled = await this.page.$eval(NextButtonxPath, el => el.disabled);
        console.log(isDisabled); // Log the result if button is disabled( true)
        return isDisabled;
    };
    async isCopyppasscodeButtonisClickbaleAndCopyPasscode() {
        await this.page.context().grantPermissions(['clipboard-read', 'clipboard-write']);
        await this.click(copyPasscodeButton);
        const clipboardText = await this.page.evaluate(async () => await navigator.clipboard.readText());
        return expect(copyPasscodeButton).toBeTruthy();
    };
    async isNextButtonEnable() {
        await this.page.waitForSelector(NextButtonxPath, { timeout: 5000 });
        const isEnable = await this.page.$eval(NextButtonxPath, el => !el.disabled);
        console.log("next button isEnable", isEnable);
        return isEnable;
    };
    async clickOnNextButton() {
        await this.click(NextButtonxPath);
    }


    async isconfirmSecrtePasscodePageVisibility() {
        await this.page.waitForSelector(ConfirmSecretpasscodePageXpath);
        return await this.isVisible(ConfirmSecretpasscodePageXpath);

    };
    async pasteSecretePasscode() {
        let delay = 2000
        const clipboardText = await this.page.evaluate(async () => await navigator.clipboard.readText());
        //console.log("clipboard", clipboardText);
        await this.page.focus(secretPasscodeFieldXpath);
        await this.fillInput(secretPasscodeFieldXpath, clipboardText)
        await this.page.waitForTimeout(delay)
    };

    async clickOnConfirmButton() {
        await this.click(confirmButton);
    }

    /// Acount Overview implementation;
    async isSecretPasscodeAutoGeneratedAndNotEditableAcountOverview() {
        // Wait for the secret passcode field to appear on the page
        console.log(secretPasscodeFieldIndropDown)
        await this.page.waitForSelector(secretPasscodeFieldIndropDown);

        // Get the value of the secret passcode (to check if it's auto-generated)
        const passcodeValue = await this.page.$eval(secretPasscodeFieldIndropDown, el => el.value);

        // Check if the input field is readonly or disabled (to ensure it is not editable)
        const isReadOnly = await this.page.$eval(secretPasscodeFieldIndropDown, el => el.readOnly);
        const isDisabled = await this.page.$eval(secretPasscodeFieldIndropDown, el => el.disabled);

        // Return true if passcode is not empty and the field is either readonly or disabled
        return passcodeValue !== '' && (isReadOnly || isDisabled);
    };

    async selectCountry(country) {
        // Click on the dropdown to open the country selection
        await this.click(countrySelectorDropdown);
        // Construct the selector for the country option
        const countryOptionSelector = `div[class*="countrySelect__option"]:has-text("${country}")`;
        // Wait for the country option to be visible in the dropdown
        await this.page.waitForSelector(countryOptionSelector, { state: 'visible' });
        await this.page.click(countryOptionSelector);
    };

    async ConvertXpathToLocator(xpath){
        const locator = await this.page.locator(xpath);
        return locator;
    }
    
    






}

module.exports = SignUp;